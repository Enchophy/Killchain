#!/usr/bin/env python3
"""
KillChain CLI - Docker wrapper for Claude Code with KillChain
Provides terminal commands to run KillChain in Docker containers
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'  # No Color
    BOLD = '\033[1m'


def print_color(color, message):
    """Print colored message to terminal"""
    print(f"{color}{message}{Colors.NC}")


def print_banner():
    """Print KillChain welcome banner"""
    print_color(Colors.CYAN, """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       Welcome to KillChain!           ‚ïë
‚ïë   Multi-Agent Project Orchestration   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
""")


def check_docker():
    """Check if Docker is installed and running"""
    try:
        subprocess.run(['docker', '--version'],
                      capture_output=True,
                      check=True,
                      text=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        print_color(Colors.RED, "‚ùå Error: Docker is not installed or not running.")
        print_color(Colors.YELLOW, "\nPlease install Docker:")
        print("  macOS: https://docs.docker.com/desktop/install/mac-install/")
        print("  Linux: https://docs.docker.com/engine/install/")
        return False


def check_api_key():
    """Check if ANTHROPIC_API_KEY is set (optional - warn if not set)"""
    api_key = os.environ.get('ANTHROPIC_API_KEY')
    if not api_key:
        print_color(Colors.YELLOW, "‚ö†Ô∏è  Note: ANTHROPIC_API_KEY environment variable is not set.")
        print_color(Colors.YELLOW, "Claude Code will prompt for authentication if needed.")
        print("\nTo set your API key:")
        print("  export ANTHROPIC_API_KEY='your-api-key-here'")
        print("\nOr add it to your ~/.bashrc or ~/.zshrc")
        print()
    return True


def prompt_yes_no(question, default=False):
    """Prompt user for yes/no question"""
    default_str = "Y/n" if default else "y/N"
    while True:
        response = input(f"{question} ({default_str}): ").strip().lower()
        if response == '':
            return default
        if response in ('y', 'yes'):
            return True
        if response in ('n', 'no'):
            return False
        print_color(Colors.YELLOW, "Please enter 'y' or 'n'")


def prompt_dangerous_mode():
    """Prompt user about dangerous mode"""
    print_color(Colors.YELLOW, "\n‚ö†Ô∏è  Dangerous Mode:")
    print("Dangerous mode uses Docker to empower Claude to run fully autonomously")
    print("by bypassing all permissions. Claude will be able to:")
    print("  ‚Ä¢ Execute any shell commands")
    print("  ‚Ä¢ Modify any files")
    print("  ‚Ä¢ Install packages")
    print("  ‚Ä¢ Make git commits")
    print_color(Colors.RED, "\nUse only in trusted, isolated environments!")
    return prompt_yes_no("\nWould you like to enable dangerous mode?", default=False)


def prompt_parallel_mode():
    """Prompt user about parallel mode"""
    print_color(Colors.CYAN, "\nüîÄ Parallel Mode:")
    print("Parallel mode allows multiple agents to run simultaneously,")
    print("speeding up execution but using more tokens.")
    return prompt_yes_no("\nWould you like to enable parallel mode?", default=False)


def get_docker_image_path():
    """Get the path to the Dockerfile"""
    # Check if we're in the KillChain repo
    script_dir = Path(__file__).parent.parent.resolve()
    dockerfile = script_dir / "docker" / "Dockerfile"

    if dockerfile.exists():
        return script_dir / "docker"

    # Check if docker directory exists in current directory
    local_docker = Path.cwd() / "docker"
    if local_docker.exists() and (local_docker / "Dockerfile").exists():
        return local_docker

    return None


def build_docker_image():
    """Build the KillChain Docker image if needed"""
    docker_dir = get_docker_image_path()

    if not docker_dir:
        print_color(Colors.RED, "‚ùå Error: Could not find docker/Dockerfile")
        print_color(Colors.YELLOW, "Please run this command from the KillChain directory,")
        print("or from a project where KillChain Docker files are installed.")
        return False

    # Check if image already exists
    try:
        result = subprocess.run(
            ['docker', 'images', '-q', 'killchain:latest'],
            capture_output=True,
            text=True,
            check=True
        )
        if result.stdout.strip():
            # Image exists
            return True
    except subprocess.CalledProcessError:
        pass

    # Build the image
    print_color(Colors.CYAN, "üî® Building KillChain Docker image...")
    print_color(Colors.YELLOW, "This may take a few minutes on first run...")

    try:
        subprocess.run(
            ['docker', 'build', '-t', 'killchain:latest', str(docker_dir)],
            check=True
        )
        print_color(Colors.GREEN, "‚úÖ Docker image built successfully!")
        return True
    except subprocess.CalledProcessError as e:
        print_color(Colors.RED, f"‚ùå Failed to build Docker image: {e}")
        return False


def run_docker_command(command, dangerous=False, parallel=False):
    """Run a KillChain command in Docker container"""
    # Map CLI commands to slash commands
    command_map = {
        'plan': 'killchain-plan',
        'execute': 'killchain-execute',
        'resume': 'killchain-resume',
        'status': 'killchain-status',
        'toolcheck': 'killchain-toolcheck',
        'approve': 'killchain-approve',
        'revise': 'killchain-revise',
        'rollback': 'killchain-rollback',
    }

    slash_command = command_map.get(command)
    if not slash_command:
        print_color(Colors.RED, f"‚ùå Unknown command: {command}")
        return False

    # Build docker run command
    docker_cmd = [
        'docker', 'run',
        '--rm',  # Remove container after exit
        '-it',   # Interactive terminal
        '-v', f'{os.getcwd()}:/app',  # Mount current directory
        '-w', '/app',
    ]

    # Add API key if set
    api_key = os.environ.get('ANTHROPIC_API_KEY')
    if api_key:
        docker_cmd.extend(['-e', f'ANTHROPIC_API_KEY={api_key}'])

    docker_cmd.extend([
        'killchain:latest',
        'claude'
    ])

    # Add dangerous mode flag
    if dangerous:
        docker_cmd.append('--dangerously-skip-permissions')

    # Add slash command
    docker_cmd.append(f'/{slash_command}')

    # Note: parallel mode is handled within Claude/agents, not as a CLI flag
    # We could pass it as an environment variable if needed
    if parallel:
        docker_cmd.insert(-1, '-e')
        docker_cmd.insert(-1, 'KILLCHAIN_PARALLEL=true')

    print_color(Colors.CYAN, f"\nüöÄ Launching KillChain {command}...")
    if dangerous:
        print_color(Colors.RED, "‚ö†Ô∏è  Running in DANGEROUS mode - all permissions bypassed")
    if parallel:
        print_color(Colors.YELLOW, "üîÄ Parallel mode enabled")
    print()

    try:
        subprocess.run(docker_cmd, check=True)
        return True
    except subprocess.CalledProcessError as e:
        print_color(Colors.RED, f"\n‚ùå Command failed with exit code {e.returncode}")
        return False
    except KeyboardInterrupt:
        print_color(Colors.YELLOW, "\n\n‚ö†Ô∏è  Interrupted by user")
        return False


def show_local_status():
    """Show status without Docker (read local .kcplan files)"""
    kcplan_dir = Path.cwd() / ".kcplan"

    if not kcplan_dir.exists():
        print_color(Colors.YELLOW, "‚ö†Ô∏è  No .kcplan directory found in current directory.")
        print("Run 'killchain plan' first to initialize a KillChain project.")
        return

    context_file = kcplan_dir / "killchain_context.json"
    if not context_file.exists():
        print_color(Colors.YELLOW, "‚ö†Ô∏è  No killchain_context.json found.")
        print("Run 'killchain plan' first to initialize a KillChain project.")
        return

    import json
    try:
        with open(context_file, 'r') as f:
            context = json.load(f)

        print_color(Colors.CYAN, "\nüìä KillChain Status:")
        print_color(Colors.BOLD, f"\nProject: {context.get('projectName', 'Unknown')}")
        print(f"Phase: {context.get('phase', 'Unknown')}")
        print(f"Components Total: {len(context.get('components', []))}")

        # Count component statuses
        components = context.get('components', [])
        statuses = {}
        for comp in components:
            status = comp.get('status', 'unknown')
            statuses[status] = statuses.get(status, 0) + 1

        print("\nComponent Status:")
        for status, count in statuses.items():
            print(f"  {status}: {count}")

        # Show blockers if any
        blockers = context.get('blockers', [])
        if blockers:
            print_color(Colors.RED, f"\n‚ö†Ô∏è  Blockers: {len(blockers)}")
            for blocker in blockers[:3]:  # Show first 3
                print(f"  - {blocker.get('description', 'Unknown')}")

        print()

    except json.JSONDecodeError:
        print_color(Colors.RED, "‚ùå Error: Could not parse killchain_context.json")
    except Exception as e:
        print_color(Colors.RED, f"‚ùå Error reading status: {e}")


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description='KillChain - Multi-Agent Project Orchestration for Claude Code',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
  plan          Initialize planning phase, create master plan
  execute       Begin implementation with multi-agent pipeline
  resume        Resume from saved checkpoint
  status        Display progress, metrics, blockers (no Docker needed)
  toolcheck     Validate tool availability
  approve       Approve milestone checkpoint
  revise        Request changes at milestone
  rollback      Revert specific component via git

Flags:
  --dangerous   Enable dangerous mode (bypass all permissions)
  --parallel    Enable parallel agent execution
  --help        Show this help message

Examples:
  killchain plan                           # Interactive mode
  killchain execute --dangerous            # Dangerous mode with prompt for parallel
  killchain resume --dangerous --parallel  # Full autonomous mode
  killchain status                         # View status (no Docker)
        """
    )

    parser.add_argument('command',
                       nargs='?',
                       choices=['plan', 'execute', 'resume', 'status',
                               'toolcheck', 'approve', 'revise', 'rollback'],
                       help='KillChain command to execute')
    parser.add_argument('--dangerous',
                       action='store_true',
                       help='Enable dangerous mode (bypass all permissions)')
    parser.add_argument('--parallel',
                       action='store_true',
                       help='Enable parallel agent execution')

    # Parse args
    args = parser.parse_args()

    # If no command provided, show help
    if not args.command:
        print_banner()
        parser.print_help()
        return 0

    # Special case: status doesn't need Docker
    if args.command == 'status':
        show_local_status()
        return 0

    # Print banner
    print_banner()

    # Check prerequisites
    if not check_docker():
        return 1

    # Check API key (warning only, not fatal)
    check_api_key()

    # Build Docker image if needed
    if not build_docker_image():
        return 1

    # Interactive mode: prompt for flags if not provided
    dangerous = args.dangerous
    parallel = args.parallel

    if not dangerous:
        dangerous = prompt_dangerous_mode()

    if not parallel:
        parallel = prompt_parallel_mode()

    # Run the command
    success = run_docker_command(args.command, dangerous, parallel)

    return 0 if success else 1


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print_color(Colors.YELLOW, "\n\n‚ö†Ô∏è  Interrupted by user")
        sys.exit(130)
